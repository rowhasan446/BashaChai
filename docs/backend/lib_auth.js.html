<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: lib/auth.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: lib/auth.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/**
 * @fileoverview Authentication and authorization utilities for the BashaChai API.
 * This module handles user authentication using both Firebase ID tokens and custom JWT tokens.
 * It also provides role-based access control, rate limiting, and user management functions.
 * 
 * @module lib/auth
 * @requires jsonwebtoken
 * @requires next/server
 * @requires firebase-admin
 * @requires ./mongodb
 */

import jwt from 'jsonwebtoken'
import { NextResponse } from 'next/server'
import admin from 'firebase-admin'
import clientPromise from './mongodb'


// Initialize Firebase Admin SDK (only initialize once)
if (!admin.apps.length) {
  try {
    const serviceAccount = {
      projectId: process.env.FIREBASE_PROJECT_ID,
      clientEmail: process.env.FIREBASE_CLIENT_EMAIL,
      privateKey: process.env.FIREBASE_PRIVATE_KEY?.replace(/\\n/g, '\n'),
    }


    admin.initializeApp({
      credential: admin.credential.cert(serviceAccount),
      projectId: process.env.FIREBASE_PROJECT_ID,
    })
  } catch (error) {
    console.error('Firebase Admin initialization error:', error)
  }
}


/**
 * Fetches user data from the database by email address.
 * This is used internally to get the user's role and other info from our database.
 * 
 * @private
 * @async
 * @param {string} email - The user's email address (will be converted to lowercase)
 * @returns {Promise&lt;Object|null>} The user object from database, or null if not found or error occurs
 * @example
 * const user = await getUserFromDatabase('john@example.com');
 * if (user) {
 *   console.log('User role:', user.role);
 * }
 */
async function getUserFromDatabase(email) {
  try {
    const client = await clientPromise
    const db = client.db('BASHACHAI')
    const user = await db.collection('user').findOne({ email: email.toLowerCase() })
    return user
  } catch (error) {
    console.error('Database lookup error:', error)
    return null
  }
}


/**
 * Verifies the authentication token from an API request.
 * This function supports both Firebase ID tokens and custom JWT tokens.
 * It first tries Firebase verification, and if that fails, falls back to JWT.
 * The user's role and permissions are fetched from the database.
 * 
 * @async
 * @param {Request} req - The Next.js request object
 * @returns {Promise&lt;Object>} User object with authentication details
 * @returns {string} return.userId - The user's unique ID
 * @returns {string} return.email - The user's email address
 * @returns {string} return.name - The user's display name
 * @returns {string} return.role - The user's role (admin, user, etc.)
 * @returns {string} return.branch - The user's branch
 * @returns {boolean} return.isStockEditor - Whether user can edit stock
 * @returns {string} return.provider - Authentication provider ('firebase' or 'jwt')
 * @throws {Error} If no token is provided or token verification fails
 * @example
 * try {
 *   const user = await verifyApiToken(request);
 *   console.log('Authenticated user:', user.email);
 * } catch (error) {
 *   return createAuthError(error.message);
 * }
 */
export async function verifyApiToken(req) {
  // Get token from Authorization header or cookies
  const authHeader = req.headers.get('authorization')
  let token = null


  if (authHeader?.startsWith('Bearer ')) {
    token = authHeader.slice(7)
  } else if (req.cookies?.get('auth-token')) {
    token = req.cookies.get('auth-token').value
  }


  if (!token) {
    throw new Error('Authentication required - no token provided')
  }


  try {
    // First, try to verify as Firebase ID token
    const decodedToken = await admin.auth().verifyIdToken(token)

    // Get user data from your database using the email
    const dbUser = await getUserFromDatabase(decodedToken.email)

    if (!dbUser) {
      throw new Error('User not found in database')
    }


    // Return combined Firebase + Database user info
    return {
      userId: decodedToken.uid,
      email: decodedToken.email,
      name: dbUser.name || decodedToken.name || decodedToken.email,
      role: dbUser.role || 'user', // Role from your database
      branch: dbUser.branch || 'main', // Branch from your database
      isStockEditor: dbUser.isStockEditor || false, // ðŸ”§ NEW: Stock Editor permission from database
      phone: dbUser.phone || '',
      profilePicture: dbUser.profilePicture || decodedToken.picture || '',
      dbUserId: dbUser._id.toString(), // Database user ID
      provider: 'firebase',
      // Include original Firebase token data
      firebase_claims: decodedToken
    }
  } catch (firebaseError) {
    // If Firebase verification fails, try custom JWT
    try {
      const decoded = jwt.verify(token, process.env.JWT_SECRET)

      // If it's a JWT token, also lookup database user for role
      if (decoded.email) {
        const dbUser = await getUserFromDatabase(decoded.email)
        if (dbUser) {
          return {
            ...decoded,
            role: dbUser.role || decoded.role || 'user',
            branch: dbUser.branch || decoded.branch || 'main',
            isStockEditor: dbUser.isStockEditor || false, // ðŸ”§ NEW: Stock Editor permission from database
            name: dbUser.name || decoded.name,
            phone: dbUser.phone || decoded.phone || '',
            profilePicture: dbUser.profilePicture || '',
            dbUserId: dbUser._id.toString(),
            provider: 'jwt'
          }
        }
      }

      return {
        ...decoded,
        provider: 'jwt'
      }
    } catch (jwtError) {
      // Log the specific errors for debugging
      console.error('Firebase token verification failed:', firebaseError.message)
      console.error('JWT token verification failed:', jwtError.message)

      if (firebaseError.code === 'auth/id-token-expired' || jwtError.name === 'TokenExpiredError') {
        throw new Error('Token expired')
      }
      if (firebaseError.code === 'auth/argument-error' || jwtError.name === 'JsonWebTokenError') {
        throw new Error('Invalid token')
      }
      throw new Error('Authentication failed')
    }
  }
}


/**
 * Checks if a user has one of the required roles.
 * Throws an error if the user doesn't have permission.
 * 
 * @param {Object} user - The user object from verifyApiToken
 * @param {string[]} [allowedRoles=['admin']] - Array of roles that are allowed
 * @returns {boolean} Returns true if user has required role
 * @throws {Error} If user doesn't have the required role
 * @example
 * // Check if user is an admin
 * requireRole(user, ['admin']);
 * 
 * // Check if user is admin or moderator
 * requireRole(user, ['admin', 'moderator']);
 */
export function requireRole(user, allowedRoles = ['admin']) {
  if (!user?.role || !allowedRoles.includes(user.role)) {
    throw new Error(`Access denied. Required role: ${allowedRoles.join(' or ')}`)
  }
  return true
}


/**
 * Creates a standardized error response for authentication failures.
 * This ensures all auth errors have a consistent format.
 * 
 * @param {string} message - The error message to send to the client
 * @param {number} [status=401] - HTTP status code (default is 401 Unauthorized)
 * @returns {NextResponse} A Next.js response object with the error
 * @example
 * return createAuthError('Invalid token', 401);
 * return createAuthError('Access denied', 403);
 */
export function createAuthError(message, status = 401) {
  return NextResponse.json(
    {
      error: message,
      timestamp: new Date().toISOString(),
    },
    {
      status,
      headers: { 'Content-Type': 'application/json' }
    }
  )
}


/**
 * In-memory storage for rate limiting.
 * Note: This is simple and works for single-server setups.
 * For production with multiple servers, consider using Redis.
 * @private
 */
const requestCounts = new Map()
const RATE_LIMIT = 100 // requests per window
const WINDOW_MS = 15 * 60 * 1000 // 15 minutes

/**
 * Checks if the request has exceeded the rate limit.
 * Uses the client's IP address to track requests.
 * Allows 100 requests per 15-minute window.
 * 
 * @param {Request} req - The Next.js request object
 * @throws {Error} If rate limit is exceeded
 * @example
 * try {
 *   checkRateLimit(request);
 * } catch (error) {
 *   return createAuthError(error.message, 429);
 * }
 */
export function checkRateLimit(req) {
  const ip = req.headers.get('x-forwarded-for')?.split(',')[0] ||
    req.headers.get('x-real-ip') ||
    'unknown'

  const now = Date.now()
  const windowStart = now - WINDOW_MS

  // Clean old entries
  requestCounts.forEach((data, key) => {
    if (data.timestamp &lt; windowStart) {
      requestCounts.delete(key)
    }
  })

  const current = requestCounts.get(ip) || { count: 0, timestamp: now }

  if (current.timestamp &lt; windowStart) {
    current.count = 1
    current.timestamp = now
  } else {
    current.count++
  }

  requestCounts.set(ip, current)

  if (current.count > RATE_LIMIT) {
    throw new Error('Too many requests - rate limit exceeded')
  }
}


/**
 * Updates a user's role and optionally their branch in the database.
 * This is useful for admin functions that manage user permissions.
 * 
 * @async
 * @param {string} email - The user's email address
 * @param {string} role - The new role to assign (e.g., 'admin', 'user')
 * @param {string|null} [branch=null] - Optional branch to assign
 * @returns {Promise&lt;boolean>} True if update was successful, false otherwise
 * @example
 * // Make a user an admin
 * const success = await updateUserRole('john@example.com', 'admin');
 * 
 * // Assign user to a branch
 * await updateUserRole('jane@example.com', 'user', 'dhaka');
 */
export async function updateUserRole(email, role, branch = null) {
  try {
    const client = await clientPromise
    const db = client.db('BASHACHAI')

    const updateData = {
      role,
      updatedAt: new Date()
    }

    if (branch !== null) {
      updateData.branch = branch
    }

    const result = await db.collection('user').updateOne(
      { email: email.toLowerCase() },
      { $set: updateData }
    )

    return result.matchedCount > 0
  } catch (error) {
    console.error('Error updating user role:', error)
    return false
  }
}


/**
 * Ensures a Firebase user exists in our database.
 * If the user doesn't exist, creates a new user record with default values.
 * This is called when a user logs in with Firebase for the first time.
 * 
 * @async
 * @param {Object} firebaseUser - The Firebase user object
 * @param {string} firebaseUser.email - User's email
 * @param {string} firebaseUser.uid - Firebase user ID
 * @param {string} [firebaseUser.displayName] - User's display name
 * @param {string} [firebaseUser.phoneNumber] - User's phone number
 * @param {string} [firebaseUser.photoURL] - User's profile picture URL
 * @returns {Promise&lt;Object|null>} The user object from database, or null if error occurs
 * @example
 * const user = await ensureUserInDatabase(firebaseAuthUser);
 * if (user) {
 *   console.log('User ready:', user.email);
 * }
 */
export async function ensureUserInDatabase(firebaseUser) {
  try {
    const client = await clientPromise
    const db = client.db('BASHACHAI')

    const existingUser = await db.collection('user').findOne({
      email: firebaseUser.email.toLowerCase()
    })

    if (!existingUser) {
      // Create new user with default role
      const newUser = {
        email: firebaseUser.email.toLowerCase(),
        name: firebaseUser.displayName || firebaseUser.email,
        phone: firebaseUser.phoneNumber || '',
        role: 'user', // Default role
        branch: 'main', // Default branch
        isStockEditor: false, // ðŸ”§ NEW: Default Stock Editor permission
        profilePicture: firebaseUser.photoURL || '',
        createdAt: new Date(),
        updatedAt: new Date(),
        firebaseUid: firebaseUser.uid
      }

      const result = await db.collection('user').insertOne(newUser)
      return { ...newUser, _id: result.insertedId }
    }

    return existingUser
  } catch (error) {
    console.error('Error ensuring user in database:', error)
    return null
  }
}
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Modules</h3><ul><li><a href="module-api_properties.html">api/properties</a></li><li><a href="module-api_properties_%255Bid%255D.html">api/properties/[id]</a></li><li><a href="module-api_reviews.html">api/reviews</a></li><li><a href="module-api_send-inquiry.html">api/send-inquiry</a></li><li><a href="module-api_user.html">api/user</a></li><li><a href="module-lib_auth.html">lib/auth</a></li><li><a href="module-lib_mongodb.html">lib/mongodb</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 4.0.5</a> on Wed Dec 03 2025 23:09:07 GMT+0600 (Bangladesh Standard Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
