<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: src/app/api/properties/[id]/route.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: src/app/api/properties/[id]/route.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/**
 * @fileoverview Individual property CRUD operations.
 * Handles fetching, updating, and deleting specific properties by ID.
 * GET is public, PUT and DELETE require authentication and ownership verification.
 * 
 * @module api/properties/[id]
 * @requires next/server
 * @requires lib/mongodb
 * @requires mongodb
 * @requires cloudinary
 * @requires lib/auth
 */

import { NextResponse } from "next/server";
import clientPromise from "../../../../../lib/mongodb";
import { ObjectId } from "mongodb";
import { v2 as cloudinary } from 'cloudinary';
import { verifyApiToken, checkRateLimit, createAuthError } from '../../../../../lib/auth';

// Validate environment variables
if (
  !process.env.CLOUDINARY_CLOUD_NAME ||
  !process.env.CLOUDINARY_API_KEY ||
  !process.env.CLOUDINARY_API_SECRET
) {
  throw new Error('Missing required Cloudinary environment variables');
}

// Configure Cloudinary
cloudinary.config({
  cloud_name: process.env.CLOUDINARY_CLOUD_NAME,
  api_key: process.env.CLOUDINARY_API_KEY,
  api_secret: process.env.CLOUDINARY_API_SECRET,
});

/**
 * Uploads a single image file to Cloudinary with automatic optimization.
 * 
 * @private
 * @async
 * @param {File} file - The image file to upload
 * @param {string} userId - The user's ID for naming the file
 * @returns {Promise&lt;Object>} Object with URL and public ID
 * @throws {Error} If file is invalid or upload fails
 */
async function uploadImageToCloudinary(file, userId) {
  // Validate file type
  if (!file.type.startsWith('image/')) {
    throw new Error(`File ${file.name} is not an image`);
  }

  // Validate file size (10MB limit)
  const maxSize = 10 * 1024 * 1024; // 10MB
  if (file.size > maxSize) {
    throw new Error(`File ${file.name} exceeds 10MB limit`);
  }

  // Convert file to buffer
  const bytes = await file.arrayBuffer();
  const buffer = Buffer.from(bytes);

  // Upload to Cloudinary
  const uploadResponse = await new Promise((resolve, reject) => {
    cloudinary.uploader
      .upload_stream(
        {
          resource_type: 'image',
          folder: 'BASHACHAI_properties',
          public_id: `property_${userId}_${Date.now()}_${Math.random().toString(36).substring(7)}`,
          transformation: [
            { width: 1200, height: 800, crop: 'fill' },
            { quality: 'auto' },
            { format: 'auto' },
          ],
        },
        (error, result) => {
          if (error) {
            console.error('Cloudinary upload error:', error);
            reject(new Error(`Cloudinary upload failed: ${error.message}`));
          } else {
            resolve(result);
          }
        }
      )
      .end(buffer);
  });

  return {
    url: uploadResponse.secure_url,
    publicId: uploadResponse.public_id,
  };
}

/**
 * Extracts the Cloudinary public ID from an image URL.
 * This is needed to delete images from Cloudinary.
 * 
 * @private
 * @param {string} imageUrl - The full Cloudinary image URL
 * @returns {string|null} The public ID, or null if extraction fails
 */
function extractPublicIdFromUrl(imageUrl) {
  try {
    // Match pattern: .../BASHACHAI_properties/property_xxx_xxx.ext
    const match = imageUrl.match(/\/BASHACHAI_properties\/([^/.]+)/);
    if (match) {
      return `BASHACHAI_properties/${match[1]}`;
    }
    return null;
  } catch (error) {
    console.error('Error extracting public ID:', error);
    return null;
  }
}

/**
 * GET /api/properties/[id]
 * Fetches a single property by its MongoDB ObjectId.
 * This is a public endpoint.
 * 
 * @async
 * @param {Request} request - The Next.js request object
 * @param {Object} params - Route parameters
 * @param {string} params.id - The property's MongoDB ObjectId (24-character hex string)
 * @returns {Promise&lt;NextResponse>} JSON response with property data
 */
export async function GET(request, { params }) {
  try {
    checkRateLimit(request);

    // ‚úÖ FIX: Await params in Next.js 15+
    const { id } = await params;

    console.log("üîç Backend received ID:", id);
    console.log("üìè ID length:", id?.length);
    console.log("üî§ ID type:", typeof id);

    if (!id || typeof id !== 'string') {
      return NextResponse.json({
        success: false,
        message: "Property ID is required"
      }, { status: 400 });
    }

    // Check if it's a valid hex string of 24 characters
    if (!/^[0-9a-fA-F]{24}$/.test(id)) {
      console.log("‚ùå ID failed hex validation");
      return NextResponse.json({
        success: false,
        message: `Invalid property ID format - must be 24 character hex string. Received: ${id}`
      }, { status: 400 });
    }

    if (!ObjectId.isValid(id)) {
      console.log("‚ùå ID failed ObjectId validation");
      return NextResponse.json({
        success: false,
        message: "Invalid MongoDB ObjectId"
      }, { status: 400 });
    }

    const client = await clientPromise;
    const db = client.db("BASHACHAI");
    const collection = db.collection("properties");

    console.log("üîç Querying database for ID:", id);

    const property = await collection.findOne({ _id: new ObjectId(id) });

    if (!property) {
      console.log("‚ùå Property not found in database");
      return NextResponse.json({
        success: false,
        message: "Property not found"
      }, { status: 404 });
    }

    console.log(`‚úÖ Fetched property: ${property.title} (ID: ${id})`);

    return NextResponse.json({
      success: true,
      data: {
        ...property,
        _id: property._id.toString(),
        createdAt: property.createdAt?.toISOString(),
        updatedAt: property.updatedAt?.toISOString()
      }
    }, { status: 200 });

  } catch (error) {
    console.error("‚ùå Error fetching property:", error);
    return NextResponse.json({
      success: false,
      message: "Error fetching property",
      error: process.env.NODE_ENV === 'development' ? error.message : 'Internal server error'
    }, { status: 500 });
  }
}

/**
 * PUT /api/properties/[id]
 * Updates an existing property. Only the owner can update their property.
 * Supports adding/removing images and updating all property fields.
 * 
 * @async
 * @param {Request} request - The Next.js request object with FormData
 * @param {Object} params - Route parameters
 * @param {string} params.id - The property's MongoDB ObjectId
 * @returns {Promise&lt;NextResponse>} JSON response with updated property data
 * @example
 * // FormData fields:
 * // - All fields from POST endpoint
 * // - existingImages: JSON string array of image URLs to keep
 * // - imagesToDelete: JSON string array of image URLs to delete
 * // - images: New image files to add
 */
export async function PUT(request, { params }) {
  let user = null;

  try {
    checkRateLimit(request);
    user = await verifyApiToken(request);
  } catch (authError) {
    console.error('‚ùå Authentication error in PUT /api/properties/[id]:', authError.message);
    return createAuthError(authError.message, 401);
  }

  try {
    // ‚úÖ FIX: Await params in Next.js 15+
    const { id } = await params;

    if (!ObjectId.isValid(id)) {
      return NextResponse.json({
        success: false,
        message: "Invalid property ID format"
      }, { status: 400 });
    }

    const client = await clientPromise;
    const db = client.db("BASHACHAI");
    const collection = db.collection("properties");

    // Check if property exists and user owns it
    const existingProperty = await collection.findOne({ _id: new ObjectId(id) });

    if (!existingProperty) {
      return NextResponse.json({
        success: false,
        message: "Property not found"
      }, { status: 404 });
    }

    if (existingProperty.createdByEmail !== user.email) {
      return NextResponse.json({
        success: false,
        message: "Unauthorized: You can only edit your own properties"
      }, { status: 403 });
    }

    const formData = await request.formData();

    // Extract form fields
    const title = formData.get('title');
    const location = formData.get('location');
    const price = formData.get('price');
    const beds = formData.get('beds');
    const baths = formData.get('baths');
    const description = formData.get('description');
    const category = formData.get('category');
    const type = formData.get('type');
    const size = formData.get('size');
    const newImageFiles = formData.getAll('images');
    const existingImagesStr = formData.get('existingImages');
    const imagesToDeleteStr = formData.get('imagesToDelete');

    console.log('üîç PUT /api/properties/[id] - User:', user.email, 'Property ID:', id);

    // Validate required fields
    if (!title || typeof title !== 'string' || title.trim().length &lt; 1) {
      return NextResponse.json({
        success: false,
        message: "Valid title is required"
      }, { status: 400 });
    }

    if (!location || typeof location !== 'string' || location.trim().length &lt; 1) {
      return NextResponse.json({
        success: false,
        message: "Valid location is required"
      }, { status: 400 });
    }

    if (!price) {
      return NextResponse.json({
        success: false,
        message: "Price is required"
      }, { status: 400 });
    }

    if (!description || typeof description !== 'string' || description.trim().length &lt; 1) {
      return NextResponse.json({
        success: false,
        message: "Valid description is required"
      }, { status: 400 });
    }

    // Parse existing images and images to delete
    const existingImages = existingImagesStr ? JSON.parse(existingImagesStr) : [];
    const imagesToDelete = imagesToDeleteStr ? JSON.parse(imagesToDeleteStr) : [];

    console.log('üìä Image management:', {
      existingImagesCount: existingImages.length,
      imagesToDeleteCount: imagesToDelete.length,
      newImagesCount: newImageFiles.filter(f => f &amp;&amp; f.size > 0).length
    });

    // Delete old images from Cloudinary
    if (imagesToDelete.length > 0) {
      console.log('üßπ Deleting old images from Cloudinary...');
      for (const imageUrl of imagesToDelete) {
        const publicId = extractPublicIdFromUrl(imageUrl);
        if (publicId) {
          try {
            await cloudinary.uploader.destroy(publicId);
            console.log(`‚úÖ Deleted image from Cloudinary: ${publicId}`);
          } catch (error) {
            console.error(`‚ùå Failed to delete image: ${publicId}`, error);
          }
        }
      }
    }

    // Upload new images
    let newImageUrls = [];
    let newImagePublicIds = [];

    if (newImageFiles &amp;&amp; newImageFiles.length > 0) {
      const validImageFiles = newImageFiles.filter(file => file &amp;&amp; file.size > 0);

      if (validImageFiles.length > 0) {
        const maxImages = 10;
        const totalImages = existingImages.length + validImageFiles.length;

        if (totalImages > maxImages) {
          return NextResponse.json({
            success: false,
            message: `Maximum ${maxImages} images allowed. You have ${existingImages.length} existing images.`
          }, { status: 400 });
        }

        try {
          console.log(`üì§ Uploading ${validImageFiles.length} new images to Cloudinary...`);

          const uploadPromises = validImageFiles.map(file =>
            uploadImageToCloudinary(file, user.userId)
          );

          const uploadResults = await Promise.all(uploadPromises);
          newImageUrls = uploadResults.map(result => result.url);
          newImagePublicIds = uploadResults.map(result => result.publicId);

          console.log(`‚úÖ Successfully uploaded ${newImageUrls.length} new images`);
        } catch (uploadError) {
          console.error('‚ùå Error uploading new images:', uploadError);

          // Cleanup newly uploaded images if error occurs
          if (newImagePublicIds.length > 0) {
            console.log('üßπ Cleaning up newly uploaded images due to error...');
            try {
              await Promise.all(
                newImagePublicIds.map(publicId =>
                  cloudinary.uploader.destroy(publicId)
                )
              );
            } catch (cleanupError) {
              console.error('‚ùå Error cleaning up images:', cleanupError);
            }
          }

          return NextResponse.json({
            success: false,
            message: 'Failed to upload new images',
            error: uploadError.message
          }, { status: 500 });
        }
      }
    }

    // Combine existing and new images
    const allImages = [...existingImages, ...newImageUrls];

    // Get public IDs for existing images that are kept
    const keptExistingPublicIds = existingImages.map(url => extractPublicIdFromUrl(url)).filter(Boolean);
    const allImagePublicIds = [...keptExistingPublicIds, ...newImagePublicIds];

    console.log('üì∏ Final image count:', {
      total: allImages.length,
      existing: existingImages.length,
      new: newImageUrls.length
    });

    // Prepare update document
    const updateDoc = {
      title: title.trim(),
      location: location.trim(),
      price: price,
      beds: parseInt(beds) || 0,
      baths: parseInt(baths) || 0,
      description: description.trim(),
      category: category || "Flat to Rent",
      type: type || "rent",
      images: allImages,
      imagePublicIds: allImagePublicIds,
      image: allImages[0] || '',
      imagePublicId: allImagePublicIds[0] || '',
      size: size || "",
      updatedAt: new Date()
    };

    // Update property in database
    const result = await collection.updateOne(
      { _id: new ObjectId(id) },
      { $set: updateDoc }
    );

    if (result.matchedCount === 0) {
      return NextResponse.json({
        success: false,
        message: "Property not found"
      }, { status: 404 });
    }

    console.log(`‚úÖ Property updated successfully: ${updateDoc.title} (ID: ${id})`);

    // Create audit log (non-blocking)
    setImmediate(async () => {
      try {
        await db.collection('audit_logs').insertOne({
          action: 'PROPERTY_UPDATED',
          propertyId: id,
          userId: user.userId,
          userEmail: user.email,
          propertyTitle: updateDoc.title,
          changes: {
            imagesAdded: newImageUrls.length,
            imagesDeleted: imagesToDelete.length,
            totalImages: allImages.length
          },
          timestamp: new Date(),
          ipAddress: request.headers.get('x-forwarded-for')?.split(',')[0] ||
            request.headers.get('x-real-ip') ||
            'unknown'
        });
      } catch (auditError) {
        console.error('Audit log error:', auditError);
      }
    });

    return NextResponse.json({
      success: true,
      message: "Property updated successfully",
      data: {
        _id: id,
        ...updateDoc,
        updatedAt: updateDoc.updatedAt.toISOString()
      }
    }, { status: 200 });

  } catch (error) {
    console.error("‚ùå Error updating property:", error);
    console.error("‚ùå Stack trace:", error.stack);

    return NextResponse.json({
      success: false,
      message: "Error updating property",
      error: process.env.NODE_ENV === 'development' ? error.message : 'Internal server error'
    }, { status: 500 });
  }
}

/**
 * DELETE /api/properties/[id]
 * Deletes a property and all its images from Cloudinary.
 * Only the owner can delete their property.
 * 
 * @async
 * @param {Request} request - The Next.js request object
 * @param {Object} params - Route parameters
 * @param {string} params.id - The property's MongoDB ObjectId
 * @returns {Promise&lt;NextResponse>} JSON response confirming deletion
 */
export async function DELETE(request, { params }) {
  let user = null;

  try {
    checkRateLimit(request);
    user = await verifyApiToken(request);
  } catch (authError) {
    console.error('‚ùå Authentication error in DELETE /api/properties/[id]:', authError.message);
    return createAuthError(authError.message, 401);
  }

  try {
    // ‚úÖ FIX: Await params in Next.js 15+
    const { id } = await params;

    if (!ObjectId.isValid(id)) {
      return NextResponse.json({
        success: false,
        message: "Invalid property ID format"
      }, { status: 400 });
    }

    const client = await clientPromise;
    const db = client.db("BASHACHAI");
    const collection = db.collection("properties");

    // Find property and verify ownership
    const property = await collection.findOne({ _id: new ObjectId(id) });

    if (!property) {
      return NextResponse.json({
        success: false,
        message: "Property not found"
      }, { status: 404 });
    }

    if (property.createdByEmail !== user.email) {
      return NextResponse.json({
        success: false,
        message: "Unauthorized: You can only delete your own properties"
      }, { status: 403 });
    }

    console.log('üîç DELETE /api/properties/[id] - User:', user.email, 'Property:', property.title);

    // Delete all images from Cloudinary
    const imagePublicIds = property.imagePublicIds || [];

    if (imagePublicIds.length > 0) {
      console.log(`üßπ Deleting ${imagePublicIds.length} images from Cloudinary...`);
      let deletedCount = 0;
      let failedCount = 0;

      for (const publicId of imagePublicIds) {
        try {
          await cloudinary.uploader.destroy(publicId);
          deletedCount++;
          console.log(`‚úÖ Deleted image: ${publicId}`);
        } catch (error) {
          failedCount++;
          console.error(`‚ùå Failed to delete image: ${publicId}`, error);
        }
      }

      console.log(`üìä Image deletion summary: ${deletedCount} deleted, ${failedCount} failed`);
    } else {
      console.log('‚ÑπÔ∏è No images to delete from Cloudinary');
    }

    // Delete property from database
    const deleteResult = await collection.deleteOne({ _id: new ObjectId(id) });

    if (deleteResult.deletedCount === 0) {
      return NextResponse.json({
        success: false,
        message: "Failed to delete property"
      }, { status: 500 });
    }

    console.log(`‚úÖ Property deleted successfully: ${property.title} (ID: ${id})`);

    // Create audit log (non-blocking)
    setImmediate(async () => {
      try {
        await db.collection('audit_logs').insertOne({
          action: 'PROPERTY_DELETED',
          propertyId: id,
          userId: user.userId,
          userEmail: user.email,
          propertyTitle: property.title,
          propertyLocation: property.location,
          imagesDeleted: imagePublicIds.length,
          timestamp: new Date(),
          ipAddress: request.headers.get('x-forwarded-for')?.split(',')[0] ||
            request.headers.get('x-real-ip') ||
            'unknown'
        });
      } catch (auditError) {
        console.error('Audit log error:', auditError);
      }
    });

    return NextResponse.json({
      success: true,
      message: "Property deleted successfully",
      data: {
        deletedPropertyId: id,
        deletedPropertyTitle: property.title,
        imagesDeleted: imagePublicIds.length
      }
    }, { status: 200 });

  } catch (error) {
    console.error("‚ùå Error deleting property:", error);
    console.error("‚ùå Stack trace:", error.stack);

    return NextResponse.json({
      success: false,
      message: "Error deleting property",
      error: process.env.NODE_ENV === 'development' ? error.message : 'Internal server error'
    }, { status: 500 });
  }
}
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Modules</h3><ul><li><a href="module-api_properties.html">api/properties</a></li><li><a href="module-api_properties_%255Bid%255D.html">api/properties/[id]</a></li><li><a href="module-api_reviews.html">api/reviews</a></li><li><a href="module-api_send-inquiry.html">api/send-inquiry</a></li><li><a href="module-api_user.html">api/user</a></li><li><a href="module-lib_auth.html">lib/auth</a></li><li><a href="module-lib_mongodb.html">lib/mongodb</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 4.0.5</a> on Wed Dec 03 2025 23:09:07 GMT+0600 (Bangladesh Standard Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
